
#include <stdlib.h>

const double over_rand_max = 1.0/RAND_MAX;

class GLManager {
public:
	GLManager() {
	// Init stuff
		quadric = gluNewQuadric();
		glClearColor( 0.1,0.3,0.4,0.0 );
		glEnable( GL_DEPTH_TEST );
		srand( time(NULL) );
		for( int i=0; i<21*21; ++i ) {
			for(int j=0; j<3; ++j)
				colors[i][j] = rand()*over_rand_max;
		}
	}
	~GLManager() {
		gluDeleteQuadric( quadric );
		glDisable( GL_DEPTH_TEST );
	}
	// OpenGL reshape
	void resize( int w, int h ) {
		glViewport( 0, 0, w, h );
		glMatrixMode( GL_PROJECTION );
		glLoadIdentity();
		gluPerspective( 120.0, (GLdouble)w/(GLdouble)h, 0.7, 700.0 );
		glMatrixMode( GL_MODELVIEW );
	}
	void display() {
		glLoadIdentity();
		glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
		// Look from (0,0,10) to (0,0,0), up to (0,1,0)
		gluLookAt( 0.0,0.0,10.0, 0.0,0.0,0.0, 0.0,1.0,0.0 );
		// sphere counter, to indicate which color to use.
		int counter = 0;
		for( double x=-10.0; x<=10.0; x+=1.0 ) {
			for( double y=-10.0; y<=10.0; y+=1.0 ) {
				glColor3dv( colors[counter] );
				sphere( x, y, 0.0 );
				++counter;
			}
		}
	}
private:
	void sphere( GLdouble x, GLdouble y, GLdouble z = 0.0 ) {
		glPushMatrix();
			glTranslated( x, y, z );
			gluSphere( quadric, 0.4, 25, 25 );
		glPopMatrix();
	}
private:
	GLUquadric* quadric;
	GLdouble colors[21*21][3];
};